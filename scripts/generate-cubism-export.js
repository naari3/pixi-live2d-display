
import { readdirSync, statSync, writeFileSync, readFileSync } from 'fs';
import { join, relative, dirname, sep } from 'path';
import { fileURLToPath } from 'url';

const __dirname = dirname(fileURLToPath(import.meta.url));
const cubismSrcDir = join(__dirname, '../cubism/src');
const outputFile = join(__dirname, '../src/cubism-all.ts');

function getAllFiles(dir, fileList = []) {
    const files = readdirSync(dir);
    files.forEach(file => {
        const filePath = join(dir, file);
        if (statSync(filePath).isDirectory()) {
            getAllFiles(filePath, fileList);
        } else {
            if (file.endsWith('.ts') && !file.endsWith('.d.ts')) {
                fileList.push(filePath);
            }
        }
    });
    return fileList;
}

const files = getAllFiles(cubismSrcDir);

const exportRegexes = [
    /^export\s+(?:abstract\s+)?class\s+(\w+)/gm,
    /^export\s+(?:const\s+)?enum\s+(\w+)/gm,
    /^export\s+interface\s+(\w+)/gm,
    /^export\s+type\s+(\w+)/gm,
    /^export\s+const\s+(\w+)/gm,
    /^export\s+function\s+(\w+)/gm,
    /^export\s+namespace\s+(\w+)/gm
];

// Tree structure to hold exports
const tree = {
    files: [],
    children: {}
};

const imports = [];

files.forEach((file, index) => {
    const content = readFileSync(file, 'utf8');
    const names = new Set();

    exportRegexes.forEach(regex => {
        let match;
        while ((match = regex.exec(content)) !== null) {
            names.add(match[1]);
        }
    });

    // Remove conflicts
    names.delete('Live2DCubismFramework');
    names.delete('iterator');

    if (names.size > 0) {
        const relativePath = relative(cubismSrcDir, file);
        const parts = relativePath.split(sep);
        const fileName = parts.pop().replace(/\.ts$/, '');
        
        let currentNode = tree;
        parts.forEach(part => {
            if (!currentNode.children[part]) {
                currentNode.children[part] = {
                    files: [],
                    children: {}
                };
            }
            currentNode = currentNode.children[part];
        });

        const importAlias = `_file_${index}`;
        const importPath = relative(cubismSrcDir, file).replace(/\\/g, '/').replace(/\.ts$/, '');
        
        imports.push(`import * as ${importAlias} from "@cubism/${importPath}";`);
        
        currentNode.files.push({
            alias: importAlias,
            names: Array.from(names)
        });
    }
});

function generateExports(node, indentLevel = 0) {
    const indent = '    '.repeat(indentLevel);
    let output = '';

    // Export from files in this directory
    node.files.forEach(file => {
        file.names.forEach(name => {
            output += `${indent}export import ${name} = ${file.alias}.${name};\n`;
        });
    });

    // Recurse into subdirectories
    Object.keys(node.children).forEach(childName => {
        output += `\n${indent}export namespace ${childName} {\n`;
        output += generateExports(node.children[childName], indentLevel + 1);
        output += `${indent}}\n`;
    });

    return output;
}

let content = `// Auto-generated by scripts/generate-cubism-export.js
${imports.join('\n')}

// Explicitly export Live2DCubismFramework from the main file only
export { Live2DCubismFramework } from "@cubism/live2dcubismframework";

${generateExports(tree)}
`;

writeFileSync(outputFile, content);
console.log(`Generated ${outputFile} with hierarchy.`);
